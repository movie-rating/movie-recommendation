import { createClient } from '@/lib/supabase/server'
import { getSessionId } from '@/lib/session'
import { getPosterUrl } from '@/lib/tmdb'
import { RecommendationsTabs } from '@/components/recommendations-tabs'
import { Header } from '@/components/header'
import { Button } from '@/components/ui/button'
import Link from 'next/link'
import { redirect } from 'next/navigation'
import { Metadata } from 'next'
import { THRESHOLDS } from '@/lib/constants'
import { searchMediaAction } from '@/app/onboarding/actions'
import { getUserPlatforms } from '@/lib/db-helpers'
import { PlatformManager } from '@/components/platform-manager'

// Force dynamic rendering since this page requires session data
export const dynamic = 'force-dynamic'

export const metadata: Metadata = {
  title: 'Your Watch List | AI-Powered Recommendations',
  description: 'View your personalized movie and TV show recommendations generated by AI based on your unique taste.',
}

export default async function RecommendationsPage() {
  const sessionId = await getSessionId()
  
  if (!sessionId) {
    redirect('/onboarding')
  }

  const supabase = await createClient()

  // Get all recommendations with feedback
  const { data: recs } = await supabase
    .from('recommendations')
    .select(`
      *,
      movie_feedback (status, rating, reason)
    `)
    .eq('session_id', sessionId)
    .order('created_at', { ascending: false })
  
  // Get user movies (movies added during onboarding or manually added to "Already Watched")
  const { data: userMovies } = await supabase
    .from('user_movies')
    .select('*')
    .eq('session_id', sessionId)
    .order('created_at', { ascending: false })
  
  // Get user's streaming platforms
  const userPlatforms = await getUserPlatforms(supabase, sessionId)
  
  // Fetch TMDB details in parallel with error handling
  const TMDB_KEY = process.env.TMDB_API_KEY
  
  const detailsPromises = (recs || []).map(async (rec) => {
    const isTV = rec.media_type === 'tv'
    const tmdbId = isTV ? rec.tmdb_tv_id : rec.tmdb_movie_id
    
    if (!tmdbId || !TMDB_KEY) return null
    
    try {
      const endpoint = isTV ? 'tv' : 'movie'
      const res = await fetch(
        `https://api.themoviedb.org/3/${endpoint}/${tmdbId}?append_to_response=credits`,
        { 
          headers: { Authorization: `Bearer ${TMDB_KEY}` },
          next: { revalidate: 3600 } // Cache for 1 hour
        }
      )
      return res.ok ? res.json() : null
    } catch (e) {
      console.error('Error fetching details:', e)
      return null
    }
  })
  
  // Batch fetch all details
  const details = await Promise.allSettled(detailsPromises)
  
  const recsWithDetails = (recs || []).map((rec, index) => ({
    ...rec,
    movieDetails: details[index].status === 'fulfilled' ? details[index].value : null
  }))

  if (!recs || recs.length === 0) {
    redirect('/onboarding')
  }
  
  // Fetch TMDB details for user movies
  const userMovieDetailsPromises = (userMovies || []).map(async (movie) => {
    const isTV = movie.media_type === 'tv'
    const tmdbId = isTV ? movie.tmdb_tv_id : movie.tmdb_movie_id
    
    // If movie has TMDB ID, fetch details directly
    if (tmdbId && TMDB_KEY) {
      try {
        const endpoint = isTV ? 'tv' : 'movie'
        const res = await fetch(
          `https://api.themoviedb.org/3/${endpoint}/${tmdbId}?append_to_response=credits`,
          { 
            headers: { Authorization: `Bearer ${TMDB_KEY}` },
            next: { revalidate: 3600 }
          }
        )
        return res.ok ? res.json() : null
      } catch (e) {
        console.error('Error fetching user movie details:', e)
        return null
      }
    }
    
    // If no TMDB ID, search by title to get poster using raw TMDB API
    if (TMDB_KEY) {
      try {
        const params = new URLSearchParams({ query: movie.movie_title })
        const res = await fetch(`https://api.themoviedb.org/3/search/multi?${params}`, {
          headers: {
            'Authorization': `Bearer ${TMDB_KEY}`,
            'Content-Type': 'application/json'
          },
          next: { revalidate: 3600 }
        })
        
        if (res.ok) {
          const data = await res.json()
          const result = data.results?.find((r: any) => r.media_type === 'movie' || r.media_type === 'tv')
          if (result) {
            // Return a minimal object with poster_path
            return {
              poster_path: result.poster_path,
              id: result.id
            }
          }
        }
      } catch (e) {
        console.error('Error searching for movie:', e)
      }
    }
    
    return null
  })
  
  const userMovieDetails = await Promise.allSettled(userMovieDetailsPromises)
  
  const userMoviesWithDetails = (userMovies || []).map((movie, index) => ({
    ...movie,
    movieDetails: userMovieDetails[index].status === 'fulfilled' ? userMovieDetails[index].value : null
  }))

  // Transform data
  const recsWithFeedback = recsWithDetails.map(rec => ({
    ...rec,
    posterUrl: getPosterUrl(rec.poster_path),
    feedback: rec.movie_feedback?.[0] || null
  }))
  
  // Get titles of recommendations that are already marked as watched
  const watchedRecTitles = new Set(
    recsWithFeedback
      .filter(r => r.feedback?.status === 'watched')
      .map(r => r.movie_title.toLowerCase().trim())
  )
  
  // Transform user movies to match recommendation format for display
  // Filter out user movies that are already in recommendations with watched status
  const userMoviesAsRecs = userMoviesWithDetails
    .filter(movie => !watchedRecTitles.has(movie.movie_title.toLowerCase().trim()))
    .map(movie => {
      const posterPath = movie.movieDetails?.poster_path || null
      const posterUrl = getPosterUrl(posterPath)
      
      return {
        id: movie.id,
        movie_title: movie.movie_title,
        media_type: movie.media_type || 'movie',
        tmdb_movie_id: movie.tmdb_movie_id,
        tmdb_tv_id: movie.tmdb_tv_id,
        reasoning: movie.reason || '', // Use user's reason as "reasoning"
        poster_path: posterPath,
        posterUrl,
        is_experimental: false,
        match_confidence: 0,
        feedback: {
          status: 'watched' as const,
          rating: movie.sentiment as any,
          reason: movie.reason
        },
        movieDetails: movie.movieDetails,
        isUserMovie: true // Flag to identify user-added movies
      }
    })
  
  // Combine recommendations and user movies
  const allMovies = [...recsWithFeedback, ...userMoviesAsRecs]

  // Count watched & rated movies (from both recommendations and user movies)
  const ratedCount = allMovies.filter(
    r => r.feedback?.status === 'watched' && r.feedback?.rating
  ).length

  // Check if user is authenticated
  const { data: { user } } = await supabase.auth.getUser()

  return (
    <div className="min-h-screen bg-background">
      <Header />
      <div className="max-w-7xl mx-auto px-4 py-6 sm:py-12">
        <div className="flex flex-col md:flex-row justify-between items-start md:items-center gap-4 mb-6 sm:mb-8">
          <div className="flex-1">
            <h1 className="text-3xl sm:text-4xl md:text-5xl font-bold mb-2 sm:mb-3">
              Your Watch List
            </h1>
            
            {/* Compact progress on mobile, detailed on desktop */}
            <div className="flex items-center gap-2 text-sm sm:text-base text-muted-foreground">
              <span className="font-medium">{ratedCount} rated</span>
              {ratedCount >= THRESHOLDS.MIN_RATINGS_FOR_MORE ? (
                <span className="text-green-600 dark:text-green-400">â€¢ Ready for more!</span>
              ) : (
                <span className="hidden sm:inline">
                  â€¢ Rate {THRESHOLDS.MIN_RATINGS_FOR_MORE - ratedCount} more to unlock new recommendations
                </span>
              )}
            </div>
            
            {/* Hide tip on mobile, show on desktop */}
            <p className="hidden sm:block text-sm text-muted-foreground mt-2">
              ðŸ’¡ Tip: Add movies you've watched in the &quot;Already Watched&quot; tab to improve your recommendations
            </p>
          </div>
          
          {!user && (
            <Button asChild size="lg" className="w-full sm:w-auto">
              <Link href="/auth/sign-up">
                <span className="hidden sm:inline">Save Progress (Sign Up)</span>
                <span className="sm:hidden">Sign Up to Save</span>
              </Link>
            </Button>
          )}
        </div>

        {/* Platform Manager */}
        <PlatformManager initialPlatforms={userPlatforms} />

        <RecommendationsTabs 
          recommendations={allMovies}
          ratedCount={ratedCount}
          userPlatforms={userPlatforms}
        />

        <div className="mt-8 sm:mt-12 flex flex-col sm:flex-row gap-3 sm:gap-4 justify-center">
          <form action={async () => {
            'use server'
            const { startOverAction } = await import('@/app/recommendations/actions')
            await startOverAction()
          }}>
            <Button variant="outline" type="submit" className="w-full sm:w-auto">
              Start Over
            </Button>
          </form>
          {user && (
            <Button variant="outline" asChild className="w-full sm:w-auto">
              <Link href="/protected">Go to Dashboard</Link>
            </Button>
          )}
        </div>
      </div>
    </div>
  )
}

