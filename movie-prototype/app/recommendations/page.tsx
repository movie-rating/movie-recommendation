import { createClient } from '@/lib/supabase/server'
import { getSessionId } from '@/lib/session'
import { getPosterUrl, batchFetchTMDBDetails, batchSearchForPosters } from '@/lib/tmdb'
import { RecommendationsTabs } from '@/components/recommendations-tabs'
import { Header } from '@/components/header'
import { Button } from '@/components/ui/button'
import Link from 'next/link'
import { redirect } from 'next/navigation'
import { Metadata } from 'next'
import { THRESHOLDS } from '@/lib/constants'
import type { Rating, MediaType } from '@/lib/types'
import { getUserPlatforms } from '@/lib/db-helpers'
import { PlatformManager } from '@/components/platform-manager'
import { WatchTogetherButton } from '@/components/watch-together-button'

// Force dynamic rendering since this page requires session data
export const dynamic = 'force-dynamic'

export const metadata: Metadata = {
  title: 'Your Watch List | AI-Powered Recommendations',
  description: 'View your personalized movie and TV show recommendations generated by AI based on your unique taste.',
}

export default async function RecommendationsPage() {
  const sessionId = await getSessionId()
  
  if (!sessionId) {
    redirect('/onboarding')
  }

  const supabase = await createClient()

  // Get all recommendations with feedback
  const { data: recs } = await supabase
    .from('recommendations')
    .select(`
      *,
      movie_feedback (status, rating, reason)
    `)
    .eq('session_id', sessionId)
    .order('created_at', { ascending: false })
  
  // Get user movies (movies added during onboarding or manually added to "Already Watched")
  const { data: userMovies } = await supabase
    .from('user_movies')
    .select('*')
    .eq('session_id', sessionId)
    .order('created_at', { ascending: false })
  
  // Get user's streaming platforms
  const userPlatforms = await getUserPlatforms(supabase, sessionId)

  if (!recs || recs.length === 0) {
    redirect('/onboarding')
  }

  // Batch fetch TMDB details for recommendations (fixes N+1 query)
  const recItems = (recs || []).map(rec => ({
    id: rec.id,
    tmdbId: rec.media_type === 'tv' ? rec.tmdb_tv_id : rec.tmdb_movie_id,
    mediaType: (rec.media_type || 'movie') as MediaType
  }))

  const recDetailsMap = await batchFetchTMDBDetails(recItems)

  const recsWithDetails = (recs || []).map(rec => ({
    ...rec,
    movieDetails: recDetailsMap.get(rec.id) || null
  }))

  // Split user movies into those with and without TMDB IDs
  const userMoviesWithTmdbId = (userMovies || []).filter(m => m.tmdb_movie_id || m.tmdb_tv_id)
  const userMoviesWithoutTmdbId = (userMovies || []).filter(m => !m.tmdb_movie_id && !m.tmdb_tv_id)

  // Batch fetch details for user movies with TMDB IDs
  const userMovieItems = userMoviesWithTmdbId.map(movie => ({
    id: movie.id,
    tmdbId: movie.media_type === 'tv' ? movie.tmdb_tv_id : movie.tmdb_movie_id,
    mediaType: (movie.media_type || 'movie') as MediaType
  }))

  // Batch search for posters for user movies without TMDB IDs
  const searchItems = userMoviesWithoutTmdbId.map(movie => ({
    id: movie.id,
    title: movie.movie_title,
    mediaType: (movie.media_type || 'movie') as MediaType
  }))

  // Run both batch operations in parallel
  const [userMovieDetailsMap, posterSearchMap] = await Promise.all([
    batchFetchTMDBDetails(userMovieItems),
    batchSearchForPosters(searchItems)
  ])

  // Combine user movies with their details
  const userMoviesWithDetails = (userMovies || []).map(movie => {
    const hasTmdbId = movie.tmdb_movie_id || movie.tmdb_tv_id

    if (hasTmdbId) {
      return {
        ...movie,
        movieDetails: userMovieDetailsMap.get(movie.id) || null
      }
    } else {
      const posterData = posterSearchMap.get(movie.id)
      return {
        ...movie,
        movieDetails: posterData ? { poster_path: posterData.poster_path, id: posterData.tmdb_id } : null
      }
    }
  })

  // Transform data
  const recsWithFeedback = recsWithDetails.map(rec => ({
    ...rec,
    posterUrl: getPosterUrl(rec.poster_path),
    feedback: rec.movie_feedback?.[0] || null
  }))
  
  // Get titles of recommendations that are already marked as watched
  const watchedRecTitles = new Set(
    recsWithFeedback
      .filter(r => r.feedback?.status === 'watched')
      .map(r => r.movie_title.toLowerCase().trim())
  )
  
  // Transform user movies to match recommendation format for display
  // Filter out user movies that are already in recommendations with watched status
  const userMoviesAsRecs = userMoviesWithDetails
    .filter(movie => !watchedRecTitles.has(movie.movie_title.toLowerCase().trim()))
    .map(movie => {
      const posterPath = movie.movieDetails?.poster_path || null
      const posterUrl = getPosterUrl(posterPath)
      
      return {
        id: movie.id,
        movie_title: movie.movie_title,
        media_type: movie.media_type || 'movie',
        tmdb_movie_id: movie.tmdb_movie_id,
        tmdb_tv_id: movie.tmdb_tv_id,
        reasoning: movie.reason || '', // Use user's reason as "reasoning"
        poster_path: posterPath,
        posterUrl,
        is_experimental: false,
        match_confidence: 0,
        feedback: {
          status: 'watched' as const,
          rating: movie.sentiment as Rating,
          reason: movie.reason
        },
        movieDetails: movie.movieDetails,
        isUserMovie: true // Flag to identify user-added movies
      }
    })
  
  // Combine recommendations and user movies
  const allMovies = [...recsWithFeedback, ...userMoviesAsRecs]

  // Count watched & rated movies (from both recommendations and user movies)
  const ratedCount = allMovies.filter(
    r => r.feedback?.status === 'watched' && r.feedback?.rating
  ).length

  // Check if user is authenticated
  const { data: { user } } = await supabase.auth.getUser()

  return (
    <div className="min-h-screen bg-background">
      <Header />
      <div className="max-w-7xl mx-auto px-4 py-6 sm:py-12">
        <div className="flex flex-col md:flex-row justify-between items-start md:items-center gap-4 mb-6 sm:mb-8">
          <div className="flex-1">
            <h1 className="text-3xl sm:text-4xl md:text-5xl font-bold mb-2 sm:mb-3">
              Your Watch List
            </h1>
            
            {/* Compact progress on mobile, detailed on desktop */}
            <div className="flex items-center gap-2 text-sm sm:text-base text-muted-foreground">
              <span className="font-medium">{ratedCount} rated</span>
              {ratedCount >= THRESHOLDS.MIN_RATINGS_FOR_MORE ? (
                <span className="text-green-600 dark:text-green-400">â€¢ Ready for more!</span>
              ) : (
                <span className="hidden sm:inline">
                  â€¢ Rate {THRESHOLDS.MIN_RATINGS_FOR_MORE - ratedCount} more to unlock new recommendations
                </span>
              )}
            </div>
            
            {/* Hide tip on mobile, show on desktop */}
            <p className="hidden sm:block text-sm text-muted-foreground mt-2">
              ðŸ’¡ Tip: Add movies you've watched in the &quot;Already Watched&quot; tab to improve your recommendations
            </p>
          </div>
          
          <div className="flex flex-col sm:flex-row gap-2 w-full sm:w-auto">
            <WatchTogetherButton sessionId={sessionId} />
            {!user && (
              <Button asChild size="lg" className="w-full sm:w-auto">
                <Link href="/auth/sign-up">
                  <span className="hidden sm:inline">Save Progress (Sign Up)</span>
                  <span className="sm:hidden">Sign Up to Save</span>
                </Link>
              </Button>
            )}
          </div>
        </div>

        {/* Platform Manager */}
        <PlatformManager initialPlatforms={userPlatforms} />

        <RecommendationsTabs 
          recommendations={allMovies}
          ratedCount={ratedCount}
          userPlatforms={userPlatforms}
        />

        <div className="mt-8 sm:mt-12 flex flex-col sm:flex-row gap-3 sm:gap-4 justify-center">
          <form action={async () => {
            'use server'
            const { startOverAction } = await import('@/app/recommendations/actions')
            await startOverAction()
          }}>
            <Button variant="outline" type="submit" className="w-full sm:w-auto">
              Start Over
            </Button>
          </form>
          {user && (
            <Button variant="outline" asChild className="w-full sm:w-auto">
              <Link href="/protected">Go to Dashboard</Link>
            </Button>
          )}
        </div>
      </div>
    </div>
  )
}

